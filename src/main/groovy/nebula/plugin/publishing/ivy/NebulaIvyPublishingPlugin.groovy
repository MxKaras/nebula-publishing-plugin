package nebula.plugin.publishing.ivy

import org.gradle.api.Action
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.repositories.ArtifactRepository
import org.gradle.api.artifacts.repositories.IvyArtifactRepository
import org.gradle.api.logging.Logger
import org.gradle.api.logging.Logging
import org.gradle.api.plugins.JavaPlugin
import org.gradle.api.plugins.WarPlugin
import org.gradle.api.publish.PublishingExtension
import org.gradle.api.publish.ivy.IvyPublication
import org.gradle.api.publish.maven.plugins.MavenPublishPlugin

/**
 * Anagolous to NebulaMavenPublishingPlugin, but for Ivy. Netflix has some very specific requirements for the resulting
 * Ivy file which doesn't jive with how Gradle generates them. This plugin is around to provide a template for other's
 * who might want to publish to an Ivy file.
 */
class NebulaIvyPublishingPlugin implements Plugin<Project> {
    private static Logger logger = Logging.getLogger(NebulaIvyPublishingPlugin);

    protected Project project
    NebulaBaseIvyPublishingPlugin basePlugin

    void apply(Project project) {
        this.project = project

        basePlugin = project.plugins.apply(NebulaBaseIvyPublishingPlugin)

        project.plugins.apply(MavenPublishPlugin) // redundant given above

        // Creating the publication, essentially we're creating this:
        //        project.publishing {
        //            repositories {
        //                mavenLocal()
        //            }
        //            publications {
        //                nebula(IvyPublication) {
        //                    from project.components.java
        //                }
        //            }
        //        }

        project.getExtensions().configure(PublishingExtension, new Action<PublishingExtension>() {
            @Override
            void execute(PublishingExtension pubExt) {
                // The name of the publication is a legacy factor from the internal system
                pubExt.publications.create('nebula', IvyPublication)

                installTask(pubExt)
            }
        })

        // The from method will force the File in any artifact, forcing their conventions to run too early since we have version in the name,
        // and the version isn't available yet.
        // WebApplication SoftwareComponent has no dependencies, since they're in the .war, Netflix doesn't model them as such.
        // if (project.plugins.hasPlugin(WarPlugin)) {
        //     from project.components.web
        // } else if (project.plugins.hasPlugin(JavaPlugin)) {
        //     from project.components.getByName('java')
        // }

        project.plugins.withType(JavaPlugin) {
            includeJavaComponent()
        }
        project.plugins.withType(WarPlugin) {
            includeWarComponent()
        }

        project.plugins.apply(ResolvedIvyPlugin)
    }


    def includeJavaComponent() {
        basePlugin.withIvyPublication { IvyPublication t ->
            def javaComponent = project.components.getByName('java')
            t.from(javaComponent)
        }
    }

    def includeWarComponent() {
        basePlugin.withIvyPublication { IvyPublication t ->
            def webComponent = project.components.getByName('web')
            // TODO Include deps somehow, since that's how Netflix likes it
            t.from(webComponent)
        }
    }

    /**
     * Make sure we have somewhere local to publish to. The problem is that there's no good way to agree on layouts,
     * so we'll just react to the existence of a repository with "Local" in its name and create an alias task.
     */
    def installTask(PublishingExtension pubExt) {
        basePlugin.withIvyPublication {
            // TODO Ensure the repository is truely local, aka file://
            pubExt.repositories.matching { ArtifactRepository repo -> repo instanceof IvyArtifactRepository && repo.name.contains('Local') }.all { IvyArtifactRepository repo ->

                // TODO convert from Camel-case
                def name = "${repo.name.toLowerCase()}-publish"

                // Make alias to publishNebulaPublicationToLocalRepository. Generated by IvyPublishDynamicTaskCreator, so just using a task name
                project.task(name)
                        .dependsOn("publishNebulaPublicationTo${repo.name.capitalize()}Repository")
                        .description("Publishes to a local ivy repository, $localDir")

            }
        }
    }
}